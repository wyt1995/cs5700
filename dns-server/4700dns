#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
from dnslib import DNSRecord, DNSHeader, RR, QTYPE, RCODE
from collections import defaultdict

class Server:
    def __init__(self, root_ip, zone_file, port):
        self.root_ip = root_ip
        self.zone_file = zone_file
        self.local = defaultdict(list)
        self.cache = defaultdict(list)
        self.domain = self.authoritative_zone()

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(("0.0.0.0", port))
        self.port = self.socket.getsockname()[1]
        self.log("Bound to port %d" % self.port)

    def authoritative_zone(self):
        domain = ""
        with open(self.zone_file, "r") as file:
            zone = file.read()
        zone = RR.fromZone(zone)
        for record in zone:
            if record.rtype == QTYPE.SOA:
                domain = record.rname
            self.local[record.rname].append(record)
        return domain

    def log(self, message):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    def send(self, addr, message):
        self.socket.sendto(message.pack(), addr)

    def recv(self, socket):
        data, addr = socket.recvfrom(65535)
        request = DNSRecord.parse(data)
        response = self.dns_resolver(request)
        self.send(addr, response)

    def dns_sendrecv(self, ip, query):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.sendto(query.pack(), (ip, 60053))
        data, _ = sock.recvfrom(65535)
        reply = DNSRecord.parse(data)
        sock.close()
        return reply

    def in_authoritative_domain(self, name):
        name = str(name).rstrip(".")
        domain = str(self.domain).rstrip(".")
        return name.endswith(domain)

    def dns_resolver(self, request):
        qname = request.q.qname
        if self.in_authoritative_domain(qname):
            response = self.local_resolver(request)
        else:
            response = self.recursive_resolver(request)
        return response

    def local_resolver(self, request):
        response = request.reply()
        qname = request.q.qname
        qtype = request.q.qtype
        rmatch = self.auth_matching(qname, qtype)
        if rmatch:
            for r in rmatch:
                response.add_answer(r)
                if r.rtype == QTYPE.CNAME:
                    a_records = self.auth_matching(r.rdata.label, qtype)
                    for a in a_records:
                        response.add_answer(a)
                elif r.rtype == QTYPE.NS:
                    a_records = self.auth_matching(r.rdata.label, QTYPE.A)
                    for a in a_records:
                        response.add_ar(a)
        else:
            response.header.rcode = RCODE.NXDOMAIN
        return response

    def recursive_resolver(self, request):
        response = request.reply()
        response.header.aa = 0
        qname = request.q.qname
        qtype = request.q.qtype
        answer = self.recursive_lookup(qname, qtype)
        if answer:
            for r in answer.rr:
                response.add_answer(r)
                if r.rtype == QTYPE.CNAME:
                    a_records = self.recursive_lookup(r.rdata.label, qtype)
                    for a in a_records.rr:
                        response.add_answer(a)
            for au in answer.auth:
                response.add_auth(au)
            for ar in answer.ar:
                response.add_ar(ar)
        else:
            response.header.rcode = RCODE.NXDOMAIN
        return response

    def auth_matching(self, qname, qtype):
        if qname in self.local:
            return [r for r in self.local[qname] if r.rtype == qtype or r.rtype == QTYPE.CNAME]
        return []

    def cache_search(self, qname, qtype):
        pass

    def recursive_lookup(self, qname, qtype):
        current = [self.root_ip]
        visited = set()
        max_depth = 10
        depth = 0
        while depth < max_depth:
            depth += 1
            for ip in current:
                if ip in visited:
                    continue
                visited.add(ip)

                # send DNS query and check the response
                query = DNSRecord.question(qname, QTYPE[qtype])
                reply = self.dns_sendrecv(ip, query)
                if not reply:
                    continue
                if reply.rr or (qtype == QTYPE.NS and reply.auth):
                    return reply

                # find ip address for the next nameserver in glue records
                ns_records = reply.auth
                glue_records = reply.ar
                next_level = []
                for ns in ns_records:
                    for ar in glue_records:
                        if ar.rname == ns.rdata.label and ar.rtype == QTYPE.A:
                            next_level.append(str(ar.rdata))
                current = next_level
        return None

    def run(self):
        seq = 0
        while True:
            socks = select.select([self.socket], [], [], 0.1)[0]
            for conn in socks:
                self.recv(conn)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('root_ip', type=str, help="The IP address of the root server")
    parser.add_argument('zone', type=str, help="The zone file for this server")
    parser.add_argument('--port', type=int, help="The port this server should bind to", default=0)
    args = parser.parse_args()
    sender = Server(args.root_ip, args.zone, args.port)
    sender.run()
