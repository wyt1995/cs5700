#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
from dnslib import DNSRecord, DNSHeader, RR, QTYPE, RCODE
from collections import defaultdict

class Server:
    def __init__(self, root_ip, zone_file, port):
        self.root_ip = root_ip
        self.zone_file = zone_file
        self.local = defaultdict(list)
        self.cache = defaultdict(list)
        self.domain = self.authoritative_zone()

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(("0.0.0.0", port))
        self.port = self.socket.getsockname()[1]

        self.log("Bound to port %d" % self.port)

    def authoritative_zone(self):
        domain = ""
        with open(self.zone_file, "r") as file:
            zone = file.read()
        zone = RR.fromZone(zone)
        for record in zone:
            if record.rtype == QTYPE.SOA:
                domain = record.rname
            self.local[record.rname].append(record)
        return domain

    def log(self, message):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    def send(self, addr, message):
        # self.log("Sending message:\n%s" % message)
        self.socket.sendto(message.pack(), addr)

    def recv(self, socket):
        data, addr = socket.recvfrom(65535)
        request = DNSRecord.parse(data)
        # self.log("Received message:\n%s" % request)

        response = self.dns_resolver(request)
        self.send(addr, response)

    def dns_resolver(self, request):
        response = request.reply()
        qname = request.q.qname
        qtype = request.q.qtype
        rmatch = self.find_matching(qname, qtype)
        if not rmatch:
            response.header.rcode = RCODE.NXDOMAIN
        for r in rmatch:
            response.add_answer(r)
            if r.rtype == QTYPE.CNAME:
                a_records = self.find_matching(r.rdata.label, qtype)
                for a in a_records:
                    response.add_answer(a)
            elif r.rtype == QTYPE.NS:
                a_records = self.find_matching(r.rdata.label, QTYPE.A)
                for a in a_records:
                    response.add_ar(a)
        return response

    def find_matching(self, qname, qtype):
        if qname in self.local:
            return [r for r in self.local[qname] if r.rtype == qtype or r.rtype == QTYPE.CNAME]
        return []

    def run(self):
        seq = 0
        while True:
            socks = select.select([self.socket], [], [], 0.1)[0]
            for conn in socks:
                self.recv(conn)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('root_ip', type=str, help="The IP address of the root server")
    parser.add_argument('zone', type=str, help="The zone file for this server")
    parser.add_argument('--port', type=int, help="The port this server should bind to", default=0)
    args = parser.parse_args()
    sender = Server(args.root_ip, args.zone, args.port)
    sender.run()
